변수 선언 시:
def 같은 함수 내 선언 시 지역 변수, 외부 선언 시 전역 변수이나, 내부 호출 시 불가능 하기 때문에 C++이나 C, java와는 반대로 내부 함수에서 Global이라는 형을 선언해 주어야만 전역 변수의 값도 변경된다.

주석 시: ''' 안의 내용은 전부 주석 /' '/ 와 같다 ''' or # 뒤의 내용은 전부 주석처리됨
주석은 #의 경우 ''' '''보다 강해 '''를 주석할 땐 # 사용시 가능

for, while의 루프문의 경우 c처럼 continue는 아예 그 자리에서 다음값의 루프로 실행되고, break역시 루프문 밖으로 나온다.

list 에러 시 'str' object has no attribute 'append'가 나타날 시 해당 형에 뒤의 형식적용을 할 수 없을 때 나타나는 에러
-> list에 대한 추가 함수 append인데, str형에 적용하려해서 나타나는 에러
해결 : list1.append(list(list2))

python function내 기능:
iterable -> 자신의 멤버를 한 번에 한나씩 리턴하는 객체. list, str, tuple, dict 등
sequence -> int 타입 인덱스를 통해 원소에 접근할 수 있는 iterable. iterable의 low category list, str, tuple 등
unpacking -> 구조체 메소드의 컴파일된 형식(format)을 지정된 데이터 형식의 반복 인스턴스를 포함하는 버퍼 압축풀기하여 스트리밍 제공

lambda, map, divmod

list 문의 다양한 형태
[a for a in 수의 배열 or 배열 if 조건식] 
[(a, b) for a, b in enumerate(배열)] 도 가능, 2개의 값 받을 시 ()필수
[a if 조건식 else 연산식 for a in 배열] 은 for 뒤의 if문 외에 else로 연산이 필요 시 if문을 뒤가 아닌 앞에 표시하고 else문을 추가하면 된다.
list(map(lambda x : x + 1, 배열))
list(map(lambda x, y : x * y, 배열, 배열))
list(map(lambda x, y : x * y if x * y > 10 else None, 배열, 배열)) -> 조건식 사용 시 else는 필수라 함 else구문 필요 없을 시 None선언

ex)
test = list(map(lambda x, a: x[a] + " " + x[a+1] 
if a < len(secW) - 2 and len(x[a]) + len(x[a+1]) + 1 <= K else None,
secW, range(len(secW)-1)))
print(test)
결과 = ['n i', 'a p', None]

map: map(function, iterable...) -> 함수를 iterable(배열 자료형)으로 하나씩 함수에 실행함.
divmod: print(*divmod(x, y)) -> 수가 클 수록 유리 a/b, a%b는 수가 작을 수록 유리
int(): int(a, b)일때 a가 b진법수 일때 10진법으로 바꿔 줌


프로그래머스 예제 클리어 {
한 줄에 K자를 적을 수 있는 메모장에 영어 단어들을 적으려 합니다. 영어 단어는 정해진 순서로 적어야 하며, 단어와 단어 사이는 공백 하나로 구분합니다. 단, 한 줄의 끝에 단어 하나를 완전히 적지 못한다면, 그 줄의 나머지 부분을 모두 공백으로 채우고 다음 줄부터 다시 단어를 적습니다.

예를 들어 한 줄에 10자를 적을 수 있고, 주어진 단어가 순서대로 ["nice", "happy", "hello", "world", "hi"] 인 경우 각 줄에 다음과 같이 적을 수 있습니다.('_'는 공백을 나타냅니다.)

첫째 줄 : "nice_happy"
둘째 줄 : "hello_____"
셋째 줄 : "world_hi"
이때, 둘째 줄에 "hello"를 적으면 단어를 적을 수 있는 남은 칸은 5칸이며, "world"를 이어서 적으려면 공백 하나를 포함하여 총 6칸이 필요합니다. 따라서 단어가 잘리게 되므로 남은 칸을 모두 공백으로 채운 후, 다음 줄에 "world"부터 다시 단어를 적어 나갑니다.

한 줄에 적을 수 있는 글자 수 K와 적을 단어가 순서대로 담긴 리스트 words가 매개변수로 주어질 때, 단어를 모두 적으면 몇 줄이 되는지 return 하도록 solution 함수를 완성해주세요.

매개변수 설명
한 줄에 적을 수 있는 글자 수 K와 적을 단어가 순서대로 담긴 리스트 words가 solution 함수의 매개변수로 주어집니다.

K는 5 이상 30 이하인 자연수입니다.
words 리스트의 길이는 1 이상 100 이하입니다.
words 리스트에 담겨있는 모든 단어는 알파벳 소문자로만 이루어져 있으며, 각 단어의 길이는 K 이하입니다.
return값 설명
단어를 모두 적으면 몇 줄이 되는지 return해주세요.

예제
K	words	return
10	["nice", "happy", "hello", "world", "hi"]	3
예제 설명
예제#1
문제의 예제와 같으며, 단어를 모두 적으면 3줄이 됩니다.}

답
def solution(K, words):
    answer = 0
    c = 0
    secW = [[]]
    result = [[] for a in range(len(words))]
    tmp = []
    line = 0
    
    secW = [[a for a in words[i]] for i in range(len(words))]
    
    while True:
        if (len(words) - 1) <= c:
            '''if len(tmp) == 0:
                c -= 1
                tmp.extend(secW[c])
            else:'''
            tmp.extend(secW[c])
            #print(tmp)
            if len(tmp) > K:
                c -= 1
                del tmp[len(secW[c-1]):len(tmp)]
                if len(tmp) < K:
                    tmp.extend(list(map(lambda x: " ", range(len(tmp), K))))
                result[line].extend(tmp)
                c += 1
                line += 1
                result[line].extend(secW[c])
                result[line].extend(list(map(lambda x: " ", range(len(result[line]), K))))
                break
            if len(tmp) <= K:
                if len(tmp) == K:
                    result[line].extend(tmp)
                    line += 1
                    tmp.clear()
                    break
                else:
                    tmp.extend(list(map(lambda x: " ", range(len(tmp), K))))
                    result[line].extend(tmp)
                    line += 1
                    tmp.clear()
                    break
            
            break
            #tmp.extend(list(map(lambda x: " ", range(len(tmp), K))))    
        else:
            tmp.extend(secW[c])
            if c < len(words) - 1:
                c += 1
            if len(tmp) >= (K - 1) and len(tmp) <= K:
                if len(tmp) == (K - 1):
                    tmp.extend(" ")
                result[line].extend(tmp)
                tmp.clear()
                line += 1
                continue
            if len(tmp) < K:
                tmp.extend(" ")
                continue
            if len(tmp) > K:
                c -= 1
                del tmp[len(secW[c-1]):len(tmp)]
                if len(tmp) < K:
                    tmp.extend(list(map(lambda x: " ", range(len(tmp), K))))
                result[line].extend(tmp)
                tmp.clear()
                line += 1
                continue
    
    #print(result)
    try:
        result.index([])
    except ValueError:
        answer = len(result)
        return answer
    del result[result.index([]):]
    
    answer = len(result)
    return answer

K = 10
words = ["nice", "happy", "hello", "world", "onion"]
ret = solution(K, words)

print("solution 함수의 반환 값은", ret, "입니다.")
